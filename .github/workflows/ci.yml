name: Run tests, publish docker image

on:
  push:
    paths-ignore:
      - "swagger/**"
  pull_request:
    paths-ignore:
      - "swagger/**"

env:
  IMAGE_NAME: workbench-server
  DOCKER_BUILDKIT: 1
  REGISTRY: ghcr.io
  TEST_BUCKETS: 7

jobs:
  # Generate test matrix dynamically by dividing spec files into buckets
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Cached LFS checkout
        uses: nschloe/action-cached-lfs-checkout@v1.2.3
        
      - name: Generate test matrix
        id: set-matrix
        run: |
          ruby generate-test-matrix.rb | tee /dev/stderr | jq -c '.' | xargs -I {} echo "matrix={}" >> $GITHUB_OUTPUT
          
      - name: Upload test bucket files
        uses: actions/upload-artifact@v4
        with:
          name: test-buckets
          path: test-bucket-*.txt

  # Build the Docker image and save it as an artifact
  build:
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Cached LFS checkout
        uses: nschloe/action-cached-lfs-checkout@v1.2.3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha
            
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            trimmed=true

  # Test jobs that run in parallel using the built image
  test:
    needs: [build, generate-matrix]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
          
    steps:
      - name: Cached LFS checkout
        uses: nschloe/action-cached-lfs-checkout@v1.2.3

      - name: Download test bucket files
        uses: actions/download-artifact@v4
        with:
          name: test-buckets

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Start services
        run: |
          # Extract the first tag from the build job output and set as environment variable
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          echo "Using image: $IMAGE_TAG"
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml up db redis upload_test analysis_test workers_test scheduler_test web --detach --wait --timeout 120
          
      - name: Debugging
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml ps
          docker ps
        if: ${{ always() }}

      - name: Run bucket ${{ matrix.bucket }} tests
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          
          # Copy test file list to container
          docker cp test-bucket-${{ matrix.bucket }}.txt $(CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml ps -q web):/app/test-files.txt
          
          # Run tests using the file list
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml exec -T web bash -c '
            if [ -f /app/test-files.txt ]; then
              cat /app/test-files.txt | xargs rspec --format progress --format html --out rspec_results_bucket_${{ matrix.bucket }}.html
            else
              echo "No test files found for bucket ${{ matrix.bucket }}"
              exit 1
            fi
          '
        env:
          RAILS_ENV: test

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: rspec-test-results-bucket-${{ matrix.bucket }}
          path: rspec_results_*.html

      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-logs-bucket-${{ matrix.bucket }}
          path: log/*test.log

      - name: Stop services
        if: always()
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml down

  # Generate API documentation (only on master branch push)
  docs:
    needs: [build, test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
      - name: Cached LFS checkout
        uses: nschloe/action-cached-lfs-checkout@v1.2.3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Start services
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          echo "Using image: $IMAGE_TAG"
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml up db redis upload_test analysis_test workers_test scheduler_test web --detach --wait --timeout 120

      - name: Generate API docs
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml exec -T web generate_docs.sh

      - name: Stop services
        if: always()
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml down

      - name: Commit swagger doc changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: |
            Update API docs

            [skip ci]
          file_pattern: swagger/**

  # Push release with version, changelog, docs, tag, and image (only on master branch and tags)
  push:
    needs: [build, test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || contains(github.ref, 'refs/tags/'))

    steps:
      - name: Cached LFS checkout
        uses: nschloe/action-cached-lfs-checkout@v1.2.3
        with:
          fetch-depth: 200

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate git describe
        id: tagger
        shell: pwsh
        run: |
          $result = @( git fetch --prune && git describe 'HEAD~' )
          $last_line = $result[-1]
          if ([string]::IsNullOrWhiteSpace($last_line)) {
            Write-Output "failed to get git describe, result was: $result"
            exit 1
          }
          echo "tag=$last_line" >> $env:GITHUB_OUTPUT

      - name: Generate changelog
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml up db redis upload_test analysis_test workers_test scheduler_test web --detach --wait --timeout 120
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml exec -T web rake changelog
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml down
        env:
          CHANGELOG_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate API docs
        run: |
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | head -n1)
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml up db redis upload_test analysis_test workers_test scheduler_test web --detach --wait --timeout 120
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml exec -T web generate_docs.sh
          CI_IMAGE="$IMAGE_TAG" docker compose -f docker-compose.yml -f docker-compose.ci.yml down

      - name: Set VERSION and commit changes
        run: |
          echo "${{ steps.tagger.outputs.tag }}" > VERSION
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Generated changelog and API docs for version ${{ steps.tagger.outputs.tag }}" -m "[skip ci]"

      - name: Create and push tag
        run: |
          git tag -a -m "Version ${{ steps.tagger.outputs.tag }}" "${{ steps.tagger.outputs.tag }}"
          git push --follow-tags

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: atruskie
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push to DockerHub
        uses: docker/build-push-action@v5
        with:
          build-args: |
            trimmed=true
            version=${{ steps.tagger.outputs.tag }}
          context: .
          push: true
          tags: qutecoacoustics/workbench-server:${{ steps.tagger.outputs.tag }},qutecoacoustics/workbench-server:latest
          labels: |
             version=${{ steps.tagger.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max